#pragma once

class MemoryManager
{
public:
	// Инициализирует менеджер памяти непрерывным блоком size байт,
	// начиная с адреса start.
	// Возвращает true в случае успеха и false в случае ошибки
	// Методы MemAlloc и MemFree должны работать с этим блоком памяти для хранения данных.
	// Указатель start должен быть выровнен по адресу, кратному sizeof(std::max_align_t)
	MemoryManager(void* start, size_t size) noexcept
	{
	}

	MemoryManager(const MemoryManager&) = delete;
	MemoryManager& operator=(const MemoryManager&) = delete;

	// Выделяет блок памяти внутри размером size байт и возвращает адрес выделенного
	// блока памяти. Возвращённый указатель должен быть выровнен по адресу, кратному align.
	// Параметр align должен быть степенью числа 2.
	// В случае ошибки (нехватка памяти, невалидные параметры) возвращает nullptr.
	// Полученный таким образом блок памяти должен быть позднее освобождён методом Free
	void* Allocate(size_t size, size_t align = sizeof(std::max_align_t)) noexcept
	{
		return nullptr;
	}

	// Освобождает область памяти, ранее выделенную методом Allocate,
	// делая её пригодной для повторного использования. После этого указатель
	// перестаёт быть валидным.
	// Если addr — нулевой указатель, метод не делает ничего
	// Если addr — не является валидным указателем, возвращённым ранее методом Allocate,
	// поведение метода не определено.
	void Free(void* addr) noexcept
	{
	}
};
